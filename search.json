[{"title":"Hexo博客中插入音乐","url":"/hexo/Hexo博客中插入音乐.html","content":"\n### **1. 前言**\n&#160;&#160;&#160;&#160; 正所谓没有逼格的博客不是好博客，而在自己搭建的博客里插入音乐或者视频能秒秒钟拉高博客的格调。Hexo作为一款优秀的静态博客生成器，当然也少不了这些吊炸天的功能。\n\n### **2. 准备工作**\n&#160;&#160;&#160;&#160; 准备工作当然是你得把自己的博客给搭建好了。在这里需要提一句，不管是搭建博客，还是后期写markdown的文章，都少不了打开各种格式文件的工具，要知道一个好的工具能让我们做事事半功倍。\n&#160;&#160;&#160;&#160; 修改主题文件里涉及到的各种文件，我都只使用了 `sublime`，这款软件不管是从界面简化程度、颜值、快捷键、还是软件大小都让我爱不释手，以至于最后我用markdown写博客的时候都在使用它，你可能会问：markdown写博客不需要边写边看渲染效果吗？其实这个渲染效果没必要随时看，只需要最后写好的时候看看，再对需要修改的地方进行微调就好，因为当非常熟悉了markdown的语法以及对应的实现效果之后，都不太去看最后渲染出来的效果。当然最初编写的时候我都是在csdn上写博客的时对markdown语法慢慢熟练起来，线下编写我也使用过MP、马克飞象等工具，但是顺手程度都感觉不如 sublime。如果实在想编写和渲染同时进行的话，可以推荐一款在线markdown编辑器：[在线markdown编辑器](https://www.zybuluo.com/mdeditor) 优点我就不多说了，因人而异，自行体验。\n\n\n### **3. 装插件**\n&#160;&#160;&#160;&#160; 首先我们需要通过命令行安装以下两款插件（当然装一个就可以了，如果一个实现不了再装另一个），这两款插件我们都可以从hexo的官方网站上查询到：[插件](https://hexo.io/plugins/)\n> hexo-tag-aplayer\n> hexo-tag-dplayer\n\n**安装方法：**\n&#160;&#160;&#160;&#160; 在你本地安装博客的根目录下右击鼠标打开`Git Bash` ，运行如下两条命令来分别安装以上的两款插件：\n> npm install hexo-tag-dplayer\n> npm install hexo-tag-aplayer\n\n&#160;&#160;&#160;&#160; 运行之后如图所示：\n\n![](http://osekt2slf.bkt.clouddn.com/blog/images/mingling.png)\n\n&#160;&#160;&#160;&#160; 此时你会在 `blog/node_modules` 目录下发现有两个`aplayer` 和 ``dplayer` 的文件夹。（这个blog文件是你在搭建博客时自定义命名的文件）\n\n\n### **4. 添加音乐**\n&#160;&#160;&#160;&#160; 在我的博客中我选择添加的是网易云音乐。首先我们打开网易云音乐的主页，然后搜索你喜欢的音乐，然后进入音乐的详情页面，点击 `生成外链播放器` ：（如下图所示）\n\n![](http://osekt2slf.bkt.clouddn.com/blog/images/music1.png)\n\n&#160;&#160;&#160;&#160; 选择 iframe 插件，复制如下图所示的代码：\n\n![](http://osekt2slf.bkt.clouddn.com/blog/images/music2.png)\n\n&#160;&#160;&#160;&#160; 以我自己的博客为例吧：因为我想把这个播放器放在博客页面的左侧栏里，所以就把以上代码复制到主题文件夹下实现左侧栏的那个模板文件里，也就是 `blog\\themes\\black-blue\\layout\\_partial\\left-col.ejs` 这个 `left-col.ejs ` 文件，（需要值得注意的是，因为所使用的主题不同，可能文件也就不一样，但是大致原理就如刚才我所提到的：想放在哪个区域，就把代码复制到实现那块区域的模板文件里）。\n&#160;&#160;&#160;&#160; 为了使得页面更加美观，我给这块代码自定义加了 div，这样方便给播放器设定样式，只要稍微懂一点前端知识的筒子，都可以随心所欲的加 css样式。这里需要提一下，播放器设定好后，默认是：打开页面即播放音乐；如果不喜欢默认打开音乐的筒子，也可以通过把代码中的 `auto=1` 修改为 `auto=0` 来关闭它。\n![](http://osekt2slf.bkt.clouddn.com/blog/images/daima.png)\n\n### **5. 实现效果**\n\n![](http://osekt2slf.bkt.clouddn.com/blog/images/music3.png)\n\n\n\n\n\n\n\n","tags":["hexo插入音乐"],"categories":["hexo"]},{"title":"程序流程控制（三）--循环（while，do..while，for）","url":"/Java/程序流程控制（三）--循环（while，do..while，for）.html","content":"\n## **4. 循环**\n### **（1）. while循环**\n> **语法：**\n> &#160;&#160;&#160;&#160;while(循环条件){\n> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;循环体\n>&#160;&#160;&#160;&#160;}\n\n<!-- more -->\n\n<font size=\"4\">**解释一下：**\n&#160;&#160;&#160;&#160;循环条件结果如果是 true，那么就执行循环体；如果是 false，就结束循环。通俗来说，就是只有满足了循环条件之后才能执行循环体。\n&#160;&#160;&#160;&#160;（循环条件只有 true 和 false 这两种情况）\n</font>\n\n\n<font size=\"4\">**还是举例说明吧：**\n&#160;&#160;&#160;&#160;打印1到100之间的数；\n&#160;&#160;&#160;&#160;打印1-100之间的所有的奇数和。\n</font>\n\n```java\n// 打印1-100之间的数\nclass Demo1{\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tint i = 1;\n\t\t\t\n\t\twhile(i <= 100){\n\t\t\tSystem.out.println(i);\t\n\t\t\ti++;\n\t\t}\n\t}\n}\n```\n\n```java\n// 打印1-100之间的所有的奇数和\nclass Demo1{\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tint i = 1; \n\t\tint sum = 0; //声明变量，用于存储奇数和\n\t\t\t\t\t\t\n\t\twhile(i <= 100){\n\t\t\tif(i%2 != 0){\n\t\t\t\tsum += i; //sum = sum + i;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tSystem.out.println(sum);\n\t\t\n\t}\n}\n//输出结果：2500\n```\n\n### **（2）. do...while循环**\n> **语法：**\n> &#160;&#160;&#160;&#160;do{\n> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;循环体\n>&#160;&#160;&#160;&#160;}while(循环条件);\n\n<font size=\"4\">**还是使用上面的例子吧：**\n&#160;&#160;&#160;&#160;打印1到100之间的数；\n&#160;&#160;&#160;&#160;打印1-100之间的所有的奇数和。\n</font>\n\n```java\n//打印1-100之间的数\nclass Demo1{\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tint i = 1; \n\t\t\n\t\tdo{\n\t\t\tSystem.out.println(i);\n\t\t\ti++;\n\t\t}while(i <= 100);\n\t\t//很明显在这里是先执行循环体，变量i自增之后再进行循环条件的判断\n\t}\n}\n```\n\n```java\n//打印1-100之间的所有奇数的和\nclass Demo1{\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tint i = 1; \n\t\tint sum = 0; //声明一个变量，用于存储奇数和\n\t\t\t\n\t\tdo{\n\t\t\tif(i%2 != 0){\n\t\t\t\tsum += i;\t\n\t\t\t}\t\t\t\t\n\t\t\ti++;\n\t\t}while(i <= 100);\n\t\t\t\n\t\tSystem.out.println(sum);\n\t}\n}\n//输出结果：2500\n```\n\n<font size=\"4\">\n&#160;&#160;&#160;&#160; 循环的相关内容总结到这里，突然想到很久以前在学C的时候，做到这样的一个习题：“让我们打印出所有三位数的水仙花数”，大脑里第一反应：神马是水仙花数，一脸懵逼，还要让我们用程序去实现它，感觉好坑爹啊，虽然最后历经波折还是把它给做出来了，现在想想都是一把辛酸泪啊。废话说的有点多了，现在既然又提到了这个题目，我还是用java语言再去做一遍吧。\n</font>\n\n```java\n// 打印出所有三位数的水仙花数\n// 什么是水仙花数：一个三位数，它的每一位数的位数次幂之和等于这个数本身，这样的数就是水仙花数。比如153\n\n/**\n*分析：\n\t\t循环条件：100-1000之间的三位数\n\t\t操作：获得这个三位数的每一位，判断是否为水仙花数，自增\n*/\n\nclass Demo1{\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tint i = 100; \n\t\t\t\n\t\tdo{\n\t\t\t// 获得三位数的每一位\n\t\t\tint a = i%10;  //个位\n\t\t\tint b = (i%100)/10; //十位\n\t\t\tint c = i/100;  //百位\n\t\t\t// 判断是否为水仙花数\n\t\t\tif((a*a*a + b*b*b + c*c*c) == i){\n\t\t\t\tSystem.out.println(i);\t\n\t\t\t}\n\t\t\t// 自增\n\t\t\ti++;\t\t\t\t\n\t\t}while(i < 1000);\n\t\t\t\n\t}\n}\n//输出结果为：153、370、371、407\n```\n\n### **（3）. for循环**\n\n> **语法：**\n> &#160;&#160;&#160;&#160;for(表达式1; 表达式2; 表达式3){\n> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;循环体\n>&#160;&#160;&#160;&#160;}\n>\n> 有幸在网上找到一张某个筒子分享的for循环执行顺序图，我就懒得再画了，在这里把它的图贴上来供大家形象的理解，谢谢这位筒子了。\n\n<font size=\"4\">**循环执行顺序（参照下图）：**\n&#160;&#160;&#160;&#160;先执行语句1，在判断循环条件是否为真，如果为真，则执行语句2，如果为假，则退出循环；\n&#160;&#160;&#160;&#160;执行完语句2，接着执行语句3；\n&#160;&#160;&#160;&#160;执行完语句3，再反过来判断循环条件是否成立，如果成立，在接着执行语句2，然后再去执行语句3。\n</font>\n&#160;&#160;&#160;&#160;![这里写图片描述](http://img.blog.csdn.net/20170626224851997?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzM4NDc4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n<font size=\"4\">**解释一下：**\n&#160;&#160;&#160;&#160;表达式1：计数器的初始化，仅初始化一次\n&#160;&#160;&#160;&#160;表达式2：循环条件的判断，需要多次执行它\n&#160;&#160;&#160;&#160;表达式3：更新计数器，也需要多次执行它\n</font>\n\n<font size=\"4\">**继续举例说明：**\n&#160;&#160;&#160;&#160;还是沿用之前的例子：打印1-100之间的所有的奇数和。\n</font>\n\n```java\n// 打印1-100之间的所有的奇数和\n\n/**\n* int i = 1; 是计数器的初始化\n* i <= 100; 是循环条件，且它要循环多少次就判断多少次\n* i++; 是计数器的累加，也是循环几次就累加几次\n*/\n\nclass Demo1{\t\n\tpublic static void main(String[] args){\n\t\t\t\n\t\tint sum = 0; //声明变量，用于存储奇数和\n\t\tfor(int i = 1; i <= 100; i++){\n\t\t\t\t\n\t\t\tif(i%2 != 0){\n\t\t\t\tsum += i;\n\t\t\t}\n\t\t\t\t\n\t\t}\n\t\tSystem.out.println(sum);\t\t\n\t}\n}\n//输出结果为：2500\n```\n\n<font size=\"4\">**再举两个比较典型的例子吧：**\n&#160;&#160;&#160;&#160;打印6行6列的*\n&#160;&#160;&#160;&#160;打印九九乘法表\n</font>\n\n```java\n//打印6行6列的*\nclass Demo1{\t\n\tpublic static void main(String[] args){\n\t\t\n\t\t//这是为了控制行\n\t\tfor(int j = 1; j <= 6; j++){\n\t\t    //这是为了控制列\n\t\t\tfor(int i = 1; i <= 6; i++){\n\t\t\t\tSystem.out.print(\"*\" + \" \"); //为了使打印出的*阵好看，再*与*之间加一个空格\n\t\t\t}\n\t\t\tSystem.out.println(); //换行\n\t\t}\n\t\t\t\n\t}\n}\n```\n\n```java\n//打印九九乘法表\nclass Demo1{\t\n\tpublic static void main(String[] args){\n\t\t\t\n\t\t//做行的循环\n\t\tfor(int i = 1; i <= 9; i++){\n\t\t\t\t//做列的循环\n\t\t\t\tfor(int j = 1; j <= i; j++){\n\t\t\t\t\tSystem.out.print(j + \"*\" + i + \"=\" + (j*i) + \"\\t\");\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t}\n\t\t\t\n\t}\n}\n```\n\n\n### **（4）. break**\n> break：结束整个循环\n\n```java\n/**\n* 一个马拉松运动员，每天早上的训练计划是围着操场跑40圈。\n* 可是，今天跑到第10圈的时候，感觉肚子很痛，不能坚持训练了，如何用程序描述呢？\n*/\n\nclass Demo1{\t\n\tpublic static void main(String[] args){\n\t\t\t\n\t\tfor(int i=1; i<=40; i++){\n\t \t\tSystem.out.println(\"跑完第\"+i+\"圈了。\");\n\t \t\t\t\t\n\t\t\t\tif(i==10){\n\t \t\t\t\tSystem.out.println(\"肚子很痛，不能跑了...\");\n\t \t\t\t\tbreak;//退出整个父级循环\n\t \t\t\t}\t\n\t\t}\n\t\tSystem.out.println(\"今天训练到此结束！\");\n\t}\n}\n```\n### **（5）. continue**\n> continue：结束当前循环，后续循环照常执行\n\n```java\n/**\n * 一个马拉松运动员，每天早上的训练计划是围着操场跑40圈。\n * 今天跑到第10圈的时候，手机响了，去接个电话回来接着跑完\n * 剩下的圈数，如何用程序描述？\n */\n\nclass Demo1{\t\n\tpublic static void main(String[] args){\n\t\t\t\n\t\tfor(int i=1; i<=40; i++){\t \t\t\t\t\n\t \t\t\t\t\n\t\t\tif(i==10){\n\t \t\t\tSystem.out.println(\"去接了个电话回来...\");\n\t \t\t\tcontinue;//结束本次循环，继续后续的循环\n\t \t\t}\n\t \t\tSystem.out.println(\"跑完第\"+i+\"圈了。\");\t\n\t\t}\n\t\tSystem.out.println(\"今天训练到此结束！\");\n\t}\n}\n```\n","tags":["循环"],"categories":["Java"]},{"title":"程序流程控制（二）--三元运算符","url":"/Java/程序流程控制（二）--三元运算符.html","content":"\n\n\n\n### **3. 三元运算符**\n> **语法：**\n> &#160;&#160;&#160;&#160;判断表达式？表达式1：表达式2\n\n<!-- more -->\n\n**<font size=\"4\">解释一下：</font>**\n&#160;&#160;&#160;&#160;如果判断表达式的运算结果为 false，那么整个表达式的结果就是 表达式2；\n&#160;&#160;&#160;&#160;如果判断表达式的运算结果为 true，那么整个表达式的结果就是 表达式1。\n&#160;&#160;&#160;&#160;<font color = \"red\">例如：sex == 1？'男'：'女';</font>\n&#160;&#160;&#160;&#160;（三元运算符适合判断2个值中使用哪一个的情况。）\n\n**<font size=\"4\">还是举个例子吧：</font>**\n&#160;&#160;&#160;&#160;最典型的选择男和女的情况，我们用1代表男，用2代表女。\n\n```java\n// 我们可以用 if 和 switch 来做选择\nclass Demo1{\t\n\t\tpublic static void main(String[] args){\n\t\t\n\t\t\tint sex = 1;\n\t\t\t\n\t\t\tif(sex == 1){\n\t\t\t\tSystem.out.println(\"男\");\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"女\");\t\n\t\t\t}\n\t\t\t\n\t\t\tswitch(sex){\n\t\t\t\tcase 1:\n\t\t\t\t\tSystem.out.println(\"男\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tSystem.out.println(\"女\");\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n}\n// 输出结果为：男 男\n```\n\n```java\n// 用 if 和 switch 来做选择时，把男或女放在变量里边\nclass Demo1{\t\n\t\tpublic static void main(String[] args){\n\t\t\n\t\t\tint sex = 1;\n\t\t\tchar sexText = ' ';\n\t\t\t\n\t\t\tif(sex == 1){\n\t\t\t\tsexText = '男';\n\t\t\t}else{\n\t\t\t\tsexText = '女';\n\t\t\t}\n\t\t\tSystem.out.println(sexText);\n\t\t\t\n\t\t\tswitch(sex){\n\t\t\t\tcase 1:\n\t\t\t\t\tsexText = '男';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tsexText = '女';\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSystem.out.println(sexText);\n\t\t}\n}\n// 输出结果为：男 男\n```\n\n```java\n// 很显然，上面我们用 if 和 switch 来实现的话，比较复杂；下面我们用三元运算符来实现它\nclass Demo1{\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tint sex = 1;\n\t\t// 判断 sex==1 是否为真，如果为真，则结果为'男'；如果为假，则结果为'女'\n\t\tchar sText = sex == 1?'男':'女';\n\t\tSystem.out.println(sText);\n\t}\n}\n// 输出结果为：男\n```\n\n\n\n\n\n","tags":["三元运算符"],"categories":["Java"]},{"title":"程序流程控制（一）— if判断、switch分支判断","url":"/Java/程序流程控制（一）— if判断、switch分支判断.html","content":"\n\n\n### **1. if判断**\n> **语法：**\n> &#160;&#160;&#160;&#160;if( 条件判断表达式 ){\n\t&#160;&#160;&#160;&#160;&#160;&#160; 执行语句...\n> &#160;&#160;&#160;&#160;}\n\n<font size=\"4\">注意：if的判断的条件的结果一定是 bolean 类型。如果条件判断的表达式的返回值是 true，则可以执行 if 内部的语句，反之，就不执行。 </font>\n\n<!-- more -->\n\n> **语法：**\n> &#160;&#160;&#160;&#160;if( 条件判断表达式 ){\n&#160;&#160;&#160;&#160;&#160;&#160; 执行语句...\n>&#160;&#160;&#160;&#160;}else{\n&#160;&#160;&#160;&#160;&#160;&#160; 执行语句...\n>&#160;&#160;&#160;&#160;}\n\n<font size=\"4\">注意：如果条件判断的表达式的返回值是 true，则可以执行 if 内部的语句，反之，就执行 else 中的语句。 </font>\n\n> **语法：**\n> &#160;&#160;&#160;&#160;if( 条件判断表达式 ){\n&#160;&#160;&#160;&#160;&#160;&#160; 执行语句...\n> &#160;&#160;&#160;&#160;}else if( 条件判断表达式1 ){\n&#160;&#160;&#160;&#160;&#160;&#160; 执行语句...\n> &#160;&#160;&#160;&#160;}else if( 条件判断表达式2 ){\n&#160;&#160;&#160;&#160;&#160;&#160; ...\n> &#160;&#160;&#160;&#160;}else{\n&#160;&#160;&#160;&#160;&#160;&#160; 执行语句...\n> &#160;&#160;&#160;&#160;}\n\n<font size=\"4\">注意：多重 if，当遇到满足第一个表达式条件时，执行当前 if 语句，并且不会再向下执行。 </font>\n\n### **2. switch分支判断**\n> **语法：**\n> &#160;&#160;&#160;&#160;switch( 表达式 ){\n>&#160;&#160;&#160;&#160;&#160;&#160; case 常量1：\n>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 执行语句1；\n>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break；\n>&#160;&#160;&#160;&#160;&#160;&#160; case 常量2：\n>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 执行语句2；\n>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break；\n>&#160;&#160;&#160;&#160;&#160;&#160;&#160;......\n>&#160;&#160;&#160;&#160;&#160;&#160; default：\n>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 执行语句n；\n>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; break；\n> &#160;&#160;&#160;&#160;}\n\n<font size=\"4\">注意：\n&#160;&#160;&#160;&#160; case后边的这个常量要和表达式的结果做等值判断，如果判断相等，就执行它下面的语句。在执行 break 的时候跳出 switch；如果一个也没有匹配上，就执行 default 默认情况。\n&#160;&#160;&#160;&#160; break 可以省略不会报错；但是要知道，如果省略就会穿透执行语句（不管是否能匹配上），直到遇到一个 break 才会跳出，所以一般情况下，我们不建议省略 break。\n</font>\n\n<font size=\"4\">举个例子：</font>\n```java\nclass Demo1{\t\n\t\tpublic static void main(String[] args){\n\t\t\n\t\t\tint dj = 1;\n\t\t\t\t\n\t\t\tswitch(dj){\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tSystem.out.println(\"*\");\n\t\t\t\t\t\t\t//break;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tSystem.out.println(\"**\");\n\t\t\t\t\t\t\t//break;\n\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\tSystem.out.println(\"***\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\tSystem.out.println(\"****\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 5:\n\t\t\t\t\t\t\tSystem.out.println(\"*****\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tSystem.out.println(\"请重新输入...\");\n\t\t\t\t\tbreak;\t\t\n\t\t\t}\t\n\t\t}\n}\n// 因为dj=1，所以输出的结果应该是“*”，但是在这里我们把“case 1”，“case 2”的“break;” 给注释掉了，所以最后的输出结果为：“*” “**” “***”\n```\n\n<font size=\"4\">switch 和 if 的区别：</font>\n<font size=\"4\" color=\"red\">&#160;&#160;&#160;&#160; if 可以做等值判断，也可以做区间判断；switch 只能做等值判断。\n</font>\n\n<font size=\"4\">举个例子吧：计算2017年的2月有多少天？</font>\n\n```java\nclass Demo1{\t\n\t\tpublic static void main(String[] args){\n\t\t\n\t\t\tint year = 2017;\n\t\t\tint month = 2;\n\t\t\tint day = 0;\n\t\t\n\t\t\tswitch(month){\n\t\t\t\t\tcase 1:\n\t\t\t\t\tcase 3:\n\t\t\t\t\tcase 5:\n\t\t\t\t\tcase 7:\n\t\t\t\t\tcase 8:\n\t\t\t\t\tcase 10:\n\t\t\t\t\tcase 12:\n\t\t\t\t\t\t\tday = 31;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\tcase 6:\n\t\t\t\t\tcase 9:\n\t\t\t\t\tcase 11:\n\t\t\t\t\t\t\tday = 30;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tif((year%400) == 0 || (year%4 == 0&& year%100 != 0)){\n\t\t\t\t\t\t\t\tday = 29;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tday = 28;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tSystem.out.println(\"一年中没有这个月份\");\n\t\t\t\t\tbreak;\t\t\n\t\t\t}\t\t\t\n\t\t\tSystem.out.println(year + \"年\"+ month+\"月有\"+day+\"天\");\n\t\t}\n}\n```\n\n\n<font size=\"4\">注意：\n&#160;&#160;&#160;&#160; switch后边括号内的表达式的类型可以是：byte，short，int，char，<font color=\"red\">string（jdk1.7以后才可以使用string类型）</font>;\n</font>\n\n<font size=\"4\">下面对string类型进行举例说明吧：</font>\n```java\nclass Demo1{\t\n\t\tpublic static void main(String[] args){\n\t\t\n\t\t\tString dj = \"a\";\n\t\t\t\t\n\t\t\tswitch(dj){\n\t\t\t\t\tcase \"a\":\n\t\t\t\t\t\t\tSystem.out.println(\"*\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"b\":\n\t\t\t\t\t\t\tSystem.out.println(\"**\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"c\":\n\t\t\t\t\t\t\tSystem.out.println(\"***\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"d\":\n\t\t\t\t\t\t\tSystem.out.println(\"****\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"e\":\n\t\t\t\t\t\t\tSystem.out.println(\"*****\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tSystem.out.println(\"请重新输入...\");\n\t\t\t\t\tbreak;\t\t\n\t\t\t}\t\n\t\t}\n}\n// 输出结果为：*\n```\n","tags":["switch分支判断"],"categories":["Java"]},{"title":"Java基础语法（五）—位运算符","url":"/Java/Java基础语法（五）—位运算符.html","content":"\n\n### **5.位运算符**\n\n**题外话：**我们都知道，在计算机中，参与计算的都是二进制数据，而二进制数据又分为原码、反码、补码，运算的时候都是用<font color=\"red\"><strong>补码</strong></font>来运算。\n\n<!-- more -->\n\n\n----------\n\n#### **（1）<<：将参与运算的二进制数据向 左 移动，在低位产生的空位用 0 来补齐。**\n\n> <font size=\"4\">**注意：**在java中，整数的默认类型为 int 型，也就是32位，而为了在下文中叙述方便，我就使用8位的byte型了。</font>\n\n\n```java\nclass Demo1{\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tbyte a = 7;\n\t\t// 把a变量的二进制的值左移2位\n\t\tSystem.out.println(a << 2); // 输出结果：28\n\t}\n}\n```\n<table><tr><td>整数 7 的二进制形式：</td><td bgcolor=\"CCCCCC\">0000</td><td bgcolor=\"CCCCCC\">0111</td></tr><tr>\n<td>整数 7 的二进制左移两位：</td><td bgcolor=\"CCCCCC\">0001</td><td bgcolor=\"CCCCCC\">1100</td></tr></table>\n\n----------\n\n```java\nclass Demo1{\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tbyte a = -7;\n\t\t// 把a变量的二进制的值左移2位\n\t\tSystem.out.println(a << 2); // 输出结果：-28\n\t}\n}\n```\n<table><tr><td>-7 原码：</td><td bgcolor=\"CCCCCC\">1000</td><td bgcolor=\"CCCCCC\">0111</td></tr><tr><td>&#160;&#160;&#160;&#160;反码：</td><td bgcolor=\"CCCCCC\">1111</td><td bgcolor=\"CCCCCC\">1000</td></tr><tr><td>&#160;&#160;&#160;&#160;补码：</td><td bgcolor=\"CCCCCC\">1111</td><td bgcolor=\"CCCCCC\">1001</td></tr><tr><td>&#160;&#160;&#160;&#160;补码：（左移之后）</td><td bgcolor=\"CCCCCC\">1110</td><td bgcolor=\"CCCCCC\">0100</td></tr><tr><td>&#160;&#160;&#160;&#160;反码：</td><td bgcolor=\"CCCCCC\">1110</td><td bgcolor=\"CCCCCC\">0011</td></tr><tr><td>&#160;&#160;&#160;&#160;原码：</td><td bgcolor=\"CCCCCC\">1001</td><td bgcolor=\"CCCCCC\">1100</td></tr></table>\n\n> &#160;&#160;&#160;&#160;&#160;&#160;<font size=\"4\">在这里需要简单解释一下，因为计算机的运算都是以补码的形式进行，而最高位的 0 或 1 代表的是符号位正或负，（以前不清楚这一点，正数的时候还好，一旦遭遇负数，脑子一团浆糊）。那么我们十进制的-7在进行移位运算之前，需要先转换成补码形式，然后才可以移位，（不要觉得我们进行到这里就结束了哈）实际上我们在控制台输出的还是 十进制的数，所以还要将移位之后的补码再转换成原码才行。</font>\n> &#160;&#160;&#160;&#160;&#160;&#160;<font size=\"4\">原码、反码、补码之间的转换我在之前的《java基础语法（二）》中就有过介绍，在这里我再说明一下吧：</font>\n> &#160;&#160;&#160;&#160;&#160;&#160;<font size=\"4\">正数：原码=反码=补码</font>\n> &#160;&#160;&#160;&#160;&#160;&#160;<font size=\"4\">负数：<font color=\"red\">原码变反码</font>：最高位符号位不变，其他数值位 0变1、1变0。</font>\n> &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<font color=\"red\" size=\"4\">反码变补码</font><font size=\"4\">：反码加1即可得。</font>\n\n----------\n\n#### **（2）>>：（带符号右移）将参与运算的二进制数据向右移动，在高位产生的空位：如果高位是0，就用0补齐；如果高位是1，就用1补齐。**\n\n```java\nclass Demo1{\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tbyte a = 7;\n\t\t// 把a变量的二进制的值右移2位\n\t\tSystem.out.println(a >> 2); // 输出结果：1\n\t}\n}\n```\n\n<table><tr><td>整数 7 的二进制形式：</td><td bgcolor=\"CCCCCC\">0000</td><td bgcolor=\"CCCCCC\">0111</td></tr>\n<tr><td>整数 7 的二进制右移两位：</td><td bgcolor=\"CCCCCC\">0000</td><td bgcolor=\"CCCCCC\">0001</td></tr></table>\n\n----------\n```java\nclass Demo1{\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tbyte a = -7;\n\t\t// 把a变量的二进制的值右移2位\n\t\tSystem.out.println(a >> 2); // 输出结果：-2\n\t\t\n\t}\n}\n```\n\n<table>\n<tr><td>-7 原码：</td><td bgcolor=\"CCCCCC\">1000</td><td bgcolor=\"CCCCCC\">0111</td></tr><tr><td>&#160;&#160;&#160;&#160;反码：</td><td bgcolor=\"CCCCCC\">1111</td><td bgcolor=\"CCCCCC\">1000</td></tr><tr><td>&#160;&#160;&#160;&#160;补码：</td><td bgcolor=\"CCCCCC\">1111</td><td bgcolor=\"CCCCCC\">1001</td></tr><tr><td>&#160;&#160;&#160;&#160;补码：（右移之后）</td><td bgcolor=\"CCCCCC\">1111</td><td bgcolor=\"CCCCCC\">1110</td></tr><tr><td>&#160;&#160;&#160;&#160;反码：</td><td bgcolor=\"CCCCCC\">1111</td><td bgcolor=\"CCCCCC\">1101</td></tr><tr><td>&#160;&#160;&#160;&#160;原码：</td><td bgcolor=\"CCCCCC\">1000</td><td bgcolor=\"CCCCCC\">0010</td></tr></table>\n \n> <font size=\"4\">负数的带符号右移运算的原理同左移原理相同，这里就不赘述了。</font>\n\n----------\n#### **（3）>>>：（无符号右移）将参与运算的二进制数据向右移动，在高位所产生的空位用 0 补齐。**\n\n```java\nclass Demo1{\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tbyte a = 7;\n\t\tSystem.out.println(a >>> 2); // 输出结果：1\t\n\t}\n}\n```\n> <font size=\"4\">正数的无符号右移和正数的带符号右移的结果相同。所以相对来说，正数的无符号右移其实没有啥太大的意义。</font>\n\n```java\nclass Demo1{\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tint a = -7;\n\t\tSystem.out.println(a >>> 2); // 输出结果：1073741822\n\t\t\n\t}\n}\n```\n\n<table><tr>\n<td>-7原码：</td><td bgcolor=\"CCCCCC\">1000 0000</td><td bgcolor=\"CCCCCC\">0000 0000</td><td bgcolor=\"CCCCCC\">0000 0000</td><td bgcolor=\"CCCCCC\">0000 0111</td></tr><tr><td>&#160;&#160;&#160;&#160;反码：</td><td bgcolor=\"CCCCCC\">1111 1111</td><td bgcolor=\"CCCCCC\">1111 1111</td><td bgcolor=\"CCCCCC\">1111 1111</td><td bgcolor=\"CCCCCC\">1111 1000</td></tr><tr><td>&#160;&#160;&#160;&#160;补码：</td><td bgcolor=\"CCCCCC\">1111 1111</td><td bgcolor=\"CCCCCC\">1111 1111</td><td bgcolor=\"CCCCCC\">1111 1111</td><td bgcolor=\"CCCCCC\">1111 1001</td></tr><tr><td>&#160;&#160;&#160;&#160;补码：（右移之后）</td><td bgcolor=\"CCCCCC\">0011 1111</td><td bgcolor=\"CCCCCC\">1111 1111</td><td bgcolor=\"CCCCCC\">1111 1111</td><td bgcolor=\"CCCCCC\">1111 1110</td></tr></table>\n\n> <font size=\"4\">注意：无符号右移只是对32位和64位的值有意义。上图中，右移后的补码最高符号位为0，所以为正数，所以原码就是它本身，那么转换成十进制之后的值为：1073741822</font>\n\n\n","tags":["左移"],"categories":["Java"]},{"title":"Java基础语法（四）—运算符之逻辑运算符","url":"/Java/Java基础语法（四）—运算符之逻辑运算符.html","content":"\n\n\n### **4.逻辑运算符**\n> **&：**当多个表达式进行运算的时候，只有所有的表达式计算结果都是 true 时，整体的结果才是 true ；\n\n| 表达式1 | 表达式2 | 结果 |\n| :------: | :------: | :------: |\n| true | true | true |\n| true | false | false |\n| false | true | false |\n| false | false | false |\n\n<!-- more -->\n\n> **注意：** 只要有一个表达式是 false，那么整体就是 false；但是有一点需要注意的是，&不管第一个表达式是不是false，所有的表达式都会全部执行。（<font color=\"red\">& 两边的表达式都要参与计算</font>）举个例来说：\n\n```java\nclass Demo1{\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tint a = 50;\n\t\tint b = 30;\t\t\n\t\tSystem.out.println((a > 60)&(b++ > 60)); \n\t\tSystem.out.println(b); // b = 31\n\t\t\n\t\t// 从最后输出的 b 的值为 31 可以看出，在这里每一个表达式（a > 60 和 b++ > 60）都会执行\n\t\t\n\t}\n}\n```\n\n*********************************************************************************************************\n\n> **|（或）：**当多个表达式进行运算的时候，只有所有的表达式计算结果都是 false 时，整体结果才是 false ；\n\n| 表达式1 | 表达式2 | 结果 |\n| :------: | :------: | :------: |\n| true | true | true |\n| true | false | true|\n| false | true | true|\n| false | false | false |\n\n> **注意：** 只要有一个表达式是 true，那么整体就是 true；这里也同&一样，| 不管第一个表达式是不是 true，所有的表达式都会全部执行。。（<font color=\"red\">| 两边的表达式也都要参与计算</font>）\n\n*********************************************************************************************************\n\n> **&&：** && 同 & 一样，但是他们之间的区别就在于：&& 如果发现第一个表达式就是 false 时，那么就不会再进行剩余的表达式的计算了。也就是说，&& 用于连接多个表达式的判断，如果第一个表达式能决定整个表达式的结果，第二个表达式就不用计算了。\n\n| 表达式1 | 表达式2 | 结果 |\n| :------: | :------: | :------: |\n| true | true | true |\n| true | false | false |\n| false | true | false |\n| false | false | false |\n\n*********************************************************************************************************\n\n> **||：** || 同 | 一样，但是他们之间的区别就在于：|| 如果发现第一个表达式就是 true 时，那么就不会再进行剩余的表达式的计算了。也就是说，|| 用于连接多个表达式的判断，如果第一个表达式能决定整个表达式的结果，第二个表达式就不用计算了。\n\n| 表达式1 | 表达式2 | 结果 |\n| :------: | :------: | :------: |\n| true | true | true |\n| true | false | true|\n| false | true | true|\n| false | false | false |\n\n********************************************************************************************************\n\n> **^（异或）：**用于连接多个表达式的判断，如果两个表达式相同就是 false，不同就是 true。（<font color=\"red\">两边都参与计算</font>）\n\n**************************************************************************************************\n\n> **!（取反）：** 如果对于表达式取反，需要用括号括上。","tags":["逻辑运算符"],"categories":["Java"]},{"title":"Java基础语法（三）—运算符","url":"/Java/Java基础语法（三）—运算符.html","content":"\n\n\n## **一、运算符**\n### **1.算数运算符**\n#### **（1）四则运算**\n> 加法：+ &#160;&#160;&#160;&#160; 减法：- &#160;&#160;&#160;&#160; 乘法：* &#160;&#160;&#160;&#160; 取整：/ &#160;&#160;&#160;&#160; 取余：% \n\n<!-- more -->\n\n```java\nclass Demo1{\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tint a = 100;\n\t\tint b = 200;\n\t\t\n\t\tint i1 = a + b; // 加法\n\t\tSystem.out.println(\"a+b=\"+i1); // i1 = 300\n\t\t\n\t\tint i2 = a - b; // 减法\n\t\tSystem.out.println(\"a-b=\"+i2); // i2 = -100\n\t\t\n\t\tint i3 = a * b; // 乘法\n\t\tSystem.out.println(\"a*b=\"+i3); // i3 = 20000\n\t\t\n\t\tint i4 = a / b; // 取整\n\t\tSystem.out.println(\"a/b=\"+i4); // i4 = 0\n\t\t\n\t\tint i5 = a % b; // 取余\n\t\tSystem.out.println(\"a%b=\"+i5); // i5 = 100\n\t\t\n\t}\n}\n```\n\n\n#### **（2）自增、自减（后++、后- -）**\n> 后加加（后减减）：先赋值，再运算；\n\n```java\nclass Demo1{\t\n\tpublic static void main(String[] args){\n\t\t\n\t\tint i1 = 1;\n\t\ti1++; // 对变量先进行赋值，在进行加1运算\n\t\tSystem.out.println(\"后加加：\" + i1); // i1 = 2\n\t\t\n\t\tint i2 = 5;\n\t\ti2--; // 对变量先赋值，在进行减1运算\n\t\tSystem.out.println(\"后减减：\" + i2); // i2 = 4\n\t\t\n\t}\n}\n```\n\n#### **（3）自增、自减（前++、前- -）**\n> 前加加（前减减）：先运算，再赋值\n\n```java\nclass Demo1{\t\n\tpublic static void main(String[] args){\n\t\n\t\tint i3 = 1;\n\t\t++i3; // 对变量先进行加1运算，再把所得结果赋值\n\t\tSystem.out.println(\"前加加后：\" + i3); // i3 = 2\n\t\t\n\t\tint i4 = 5;\n\t\t--i4; // 对变量先进行减1运算，再把所得结果赋值\n\t\tSystem.out.println(\"前减减后：\" + i4); // i4 = 4\n\t\t\n\t}\n}\n```\n\n**注意：**\n&#160;&#160;&#160;&#160;当后加加（后减减）和其他代码在同一行的时候，先使用加加（减减）之前的值；如果不在同一行，后面的一行就会使用加加（减减）之后的值。\n\n```java\nclass Demo1{\t\n\tpublic static void main(String[] args){\n\t\n\t\tint i5 = 10;\n\t\tSystem.out.println(\"后加加与其他代码同行：\" + (i5++)); // 输出结果：10\n\t\tSystem.out.println(i5); // 输出结果：11\n\t\t\n\t}\n}\n```\n\n**注意：**\n&#160;&#160;&#160;&#160;当前加加（前减减）和其他代码在同一行的时候，先进行加1（减1）运算，再使用运算后的值；\n\n```java\nclass Demo1{\t\n\tpublic static void main(String[] args){\n\t\n\t\tint i6 = 15;\n\t\tSystem.out.println(\"前加加与其他代码同行：\" + (++i6)); // 输出结果：16\n\t\tSystem.out.println(i6); // 输出结果：16\t\n\t}\n}\n```\n\n### **2.赋值运算符**\n&#160;&#160;&#160;&#160; =：赋值\n&#160;&#160;&#160;&#160; +=：比如 a += 2; 相当于 a = a + 2;\n&#160;&#160;&#160;&#160; -=：比如 a -= 2; 相当于 a = a - 2;\n&#160;&#160;&#160;&#160; /=：同理\n&#160;&#160;&#160;&#160; %=：同理\n&#160;&#160;&#160;&#160; *=：同理\n\n### **3.比较运算符**\n&#160;&#160;&#160;&#160; **==：** 判断双等号两边是否相等；\n\n&#160;&#160;&#160;&#160; **不等于：**！=\n\n&#160;&#160;&#160;&#160; **大于：** >\n\n&#160;&#160;&#160;&#160; **大于等于：** >=\n\n&#160;&#160;&#160;&#160; **小于：** <\n\n&#160;&#160;&#160;&#160; **小于等于：** <=\n\n\n","tags":["比较运算符"],"categories":["Java"]},{"title":"Java基础语法（二）—基本数据类型转换","url":"/Java/Java基础语法（二）—基本数据类型转换.html","content":"\n\n\n## **一、基本数据类型转换**\n&#160;&#160;&#160;&#160; 8种基本数据类型除了boolean类型外，都可相互转换。\n\n### **1.自动类型转换**\n\n &#160;&#160;&#160;&#160;变量在做运算的时候，可能产生溢出的情况，那么此时java语言将采用自动类型转换的方式来处理。\n &#160;&#160;&#160;&#160;小空间的数据类型和大空间的数据类型的数运算时，会向大空间的数据类型转换。\n\n<!-- more -->\n\n > byte-->short-->int-->long-->float-->double\n \n(1) byte、short、char类型在做计算的时候会自动的把数据类型提升为 int 型\n ```java\nclass Demo1{\n\tpublic static void main(String[] args){\n\t\t//byte在做运算的时候会自动的提升成int型\n\t\tbyte a = 16;\n\t\t//错误：byte b = a + 1;\n\t\tint b = a + 1;\n\t\tSystem.out.println(b);\n\n\t\t//char类型的数据在参与运算的时候，每一个char背后都对应一个数值类型ASCII码，参与计算的是ASCII码\n\t\tchar c = 'a'; //这里的字符a对应的十进制数为97\n\t\tint d = c + 1;\n\t\tSystem.out.println(d);\n\t\t}\n}\n ```\n(2) int 类型和其他的数值计算时，也会溢出，但int不会提升 而是直接损失精度\n   ```java\nclass Demo1{\n\tpublic static void main(String[] args){\n\t\n\t\t//int一旦达到最大值就会损失精度\n\t\tint e = 2147483647; //2147483647 为int的最大值\n\t\t//int不能提升成long\n\t\tlong f = e + 1;\n\t\tSystem.out.println(f); //f = -2147483648\n\t\t}\n}\n ```\n \n &#160;&#160;&#160;&#160; &#160;&#160;&#160;&#160; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int 为4个字节，所以int 的最大值为：\n    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &#160;&#160;&#160;&#160; &#160;&#160;&#160;&#160;0111 1111   1111 1111   1111 1111   1111 1111\n     &#160;&#160;&#160;&#160; &#160;&#160;&#160;&#160; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;+&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;1\n  &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; &#160;&#160;&#160;&#160; &#160;&#160;&#160;&#160;1000 0000   0000 0000   0000 0000   0000 0000\n\n(3) 任何的整数类型和 long 类型做运算都会转换成 long 类型\n```java\nclass Demo1{\n\tpublic static void main(String[] args){\n\t\n\t\tlong l1 = 200; \n\t\tbyte a = 10;\n\t\tlong l2 = l1 + a;\n\t\tSystem.out.println(l2); // l2 = 210\n\t\t}\n}\n ```\n(4) 常量在做运算的时候，只要不超出定义的数据类型的范围就不会报错，不会发生数据类型的自动提升\n ```java\n class Demo1{\n\tpublic static  void main(String[] args){\n\t\t//这是不报错的情况\n\t\tbyte b1 = 3 + 20;\n\t\tSystem.out.println(b1); // b1 = 23\n\n\t\t//这是报错的情况\n\t\tbyte b2 = 127 + 1; // 会造成溢出\n\t\tSystem.out.println(b2);\n\t\t}\n }\n ```\n(5) float 类型（或double类型）和常量计算，会自动转换成 float 类型（或double类型）\n ```java\n class Demo1{\n\tpublic static  void main(String[] args){\n\t\tfloat f1 = 15.3f;\n\t\tfloat f2 = f1 + 1;\n\t\tSystem.out.println(f2); // f2 = 16.3\n\t\t}\n }\n ```\n(6) float 类型和 float 类型计算，不会有数据类型的提升\n ```java\n class Demo1{\n\tpublic static  void main(String[] args){\n\t\tfloat f1 = 15.3f;\n\t\tfloat f2 = 10.0f;\n\t\tfloat f3 = f1 + f2;\n\t\tSystem.out.println(f3); // f3 = 25.3\n\t\t}\n }\n ```\n(7) float 类型（或者double类型）和任何整数类型计算，都会转换成 float类型（或者double类型）\n ```java\n  class Demo1{\n\tpublic static  void main(String[] args){\n\t\tbyte b = 100;\n\t\tshort s = 20;\n\t\tint i = 40;\n\t\tlong l = 100;\n\t\tfloat f = 13.2f;\n\t\t\n\t\tfloat f1 = f + b;\n\t\tSystem.out.println(f1); // f1 = 113.2\n\t\t\n\t\tfloat f2 = f + s;\n\t\tSystem.out.println(f2); // f2 = 33.2\n\n\t\tfloat f3 = f + i;\n\t\tSystem.out.println(f3); // f3= 53.2\n\n\t\tfloat f4 = f + l;\n\t\tSystem.out.println(f4); // f4 = 113.2\n\t\t}\n }\n ```\n(8) double 类型和 float 类型计算，会自动转换成 double 类型\n\n### **2.强制类型转换**\n\n &#160;&#160;&#160;&#160;大空间的数据类型向小空间的数据类型去转换。\n &#160;&#160;&#160;&#160;语法：<目标数据类型>变量名\n \n<font color=\"red\">(1) int型转换为byte型</font>\n \n  ```java\n  // 数值8是既在int范围里，也在byte范围里，所以转换之后不会有啥问题\n  \n class Demo1{\n\tpublic static void main(String[] args){\n\t\t// 把int型强制转换成byte型\n\t\tint i = 8;\n\t\tbyte b = (byte)i;\n\t\tSystem.out.println(b); // b= 8\n\t\t}\n }\n ```\n \n**转换原理：**\n &#160;&#160;&#160;&#160;int 类型的8：&#160;&#160;&#160;&#160;&#160;&#160;00000000   00000000   00000000   00001000\n &#160;&#160;&#160;&#160;short 类型的8：&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;00000000   00001000\n &#160;&#160;&#160;&#160;byte 类型的8：&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;00001000\n &#160;&#160;&#160;&#160;通过观察截取之后的二进制数 0000 1000 最高位符号位是0，所以这是一个正数，而计算机中所有的数据都是以补码的形式出现的，所以要计算它的补码；\n &#160;&#160;&#160;&#160;正数：原码 = 反码 = 补码\n &#160;&#160;&#160;&#160;最终看到的结果还是：0000 1000（最高位符号位不运算，数值位转化为十进制的8，因0为正，所以为+8）\n\n\n  ```java\n  // 数值130是只在int范围里，不在byte范围里，所以这里强制转换之后会损失精度\n  \n class Demo1{\n\tpublic static void main(String[] args){\n\t\t// 把int型强制转换成byte型\n\t\tint i = 130;\n\t\tbyte b = (byte)i;\n\t\tSystem.out.println(b); // b = -126\n\t\t}\n }\n ```\n \n**转换原理：**\n&#160;&#160;&#160;&#160; 数据130是int类型的十进制数据；\n&#160;&#160;&#160;&#160; 第一步：十进制的130转换成二进制数据 1000 0010；\n&#160;&#160;&#160;&#160; 第二步：占4个字节的int型，做截取的过程如下：\n&#160;&#160;&#160;&#160; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int 类型的130：&#160;&#160;&#160;&#160;&#160;00000000   00000000   00000000   10000010\n&#160;&#160;&#160;&#160; &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;byte 类型的130：&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10000010\n&#160;&#160;&#160;&#160; 通过观察最高位符号是1，所以这是一个负数，而计算机中所有的数据都是以补码的形式出现的，所以要算它的补码；\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 原码：1000 0010（原码变反码：最高位符号位不变，其他数值位0变1，1变0）\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 反码：1111 1101（反码变补码：反码加1即可得）\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 补码：1111 1110\n&#160;&#160;&#160;&#160; 最终看到的结果就是：1111 1110（最高位是符号位不运算，数值位转化为十进制得126，因1为负，所以为-126）\n\n<font color=\"red\">(2) float型转换为int、byte、short、long型，都是一样的（下面以int为例）</font>\n ```java\n  class Demo1{\n\tpublic static void main(String[] args){\n\t\t// 小数强制转换为整数后，会舍弃小数位\n\t\tfloat f = 12.5f;\n\t\tint i1 = (int)f;\n\t\tSystem.out.println(i1); // i1 = 12\n\t\t}\n }\n ```\n \n<font color=\"red\">(3) double 类型转化成 float类型</font>\n  ```java\n    class Demo1{\n\t\tpublic static void main(String[] args){\n\t\t\t// double数据类型转换成float类型\n\t\t\tdouble d = 20.3;\n\t\t\tfloat f = (float)d; \n\t\t\tSystem.out.println(f); // f = 20.3\n\t\t}\n }\n  ```","tags":["基本数据类型转换"],"categories":["Java"]},{"title":"Java基础语法（一）—标识符、关键字、常变量、数据类型","url":"/Java/Java基础语法（一）—标识符、关键字、常变量、数据类型.html","content":"\n\n\n\n##  **一、标识符**\n\n### **1. 定义**\n> 在java语言中，对各种变量、方法和类等要素命名时所使用的字符序列就是标识符。\n\n<!-- more -->\n\n### **2. 使用规范**\n> （1） 使用26个英文字母大小写，数字0-9，符号 _ 和 $\n> （2） 数字不能开头，且严格区分大小写\n\n### **3. 标识符规范**\n类名和接口：\n&#160;&#160;&#160;&#160;首字符大写，如果是多个单词，每一个单词的首字符都要大写。\n&#160;&#160;&#160;&#160;例如：XxxYyyZzz （PersonDao）\n\n变量名和方法名：\n&#160;&#160;&#160;&#160;第一个单词的首字符小写，后续的单词首字符大写。\n&#160;&#160;&#160;&#160;例如：xxxYyyZzz （addPerson）\n\n常量：\n&#160;&#160;&#160;&#160;所有字符都大写，多个单词之间使用下划线_隔开。\n&#160;&#160;&#160;&#160;例如：XXX_YYY_ZZZ （PERSON_COUNT 人的数量）\n\n包名：\n&#160;&#160;&#160;&#160;都小写\n&#160;&#160;&#160;&#160;例如：xxx.yyy.zzz （com.nun.dao）\n\n## **二、关键字**\n### **1. 定义**\n> JDK定义的标识符就是关键字，也是被java语言赋予了特殊含义的单词。 <font color=\"#D2691E\">（特点：关键字中所有字母都为小写）</font>\n\n### **2. 常用的关键字**\n![这里写图片描述](http://img.blog.csdn.net/20170524211529945?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzM4NDc4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n![这里写图片描述](http://img.blog.csdn.net/20170524211553867?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzM4NDc4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n## **三、常量和变量**\n**题外话：**\n&#160;&#160;&#160;&#160;在了解变量和常量之前呢，我们来说说一些题外话。我们都知道任何程序的运行都离不开内存，都要从硬盘上把程序调到内存里。（下面我们以运行java程序为例）\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(1) 首先我们需要开辟内存空间（对于java来说是JVM）；\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(2) 接下来是提取数据（也就是我们编译好的 .class 文件）；\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(3) 最后是CPU调度运行。\n&#160;&#160;&#160;&#160;常量和变量就是在内存中做数据交换的一个过程。\n\n### **1.常量**\n在程序的<font color=\"#D2691E\">运行期</font>数据不发生变化的量就是常量。（这里的运行期我在“初识java”中有提到）\n\n### **２.变量**\n**定义：**\n&#160;&#160;&#160;&#160;在程序运行的过程中，存储可以 变化的数据 的量。（这个量其实就是一个内存空间）\n\n**对变量的通俗的理解：**\n&#160;&#160;&#160;&#160;(1) 内存中的一个存储区域；\n&#160;&#160;&#160;&#160;(2) 该区域有自己的名称（变量名）和类型（数据类型）；（变量是通过使用变量名来访问这个区域的）\n&#160;&#160;&#160;&#160;(3) java中每个变量必须先声明，后使用；\n&#160;&#160;&#160;&#160;(4) 使用变量之前先初始化值；（<font color=\"#D2691E\">类的属性不需要初始化值</font>）\n\n**定义变量的格式：**\n&#160;&#160;&#160;&#160;语法：数据类型  变量名 = 初始化值；\n&#160;&#160;&#160;&#160;例如：byte age = 10; （意思是：在运行时，会在内存中开辟一个字节的空间，这个空间的名字叫age，其存的值为10）\n&#160;&#160;&#160;&#160;变量的定义位置：定义在方法中或者是语句块中；\n\n**注意：**\n&#160;&#160;&#160;&#160;在下文介绍的8种数据类型是有默认值的，这个默认值如果在变量中是不能使用的，必须是在类的属性中使用，因为类的属性可以不赋初始值。\n&#160;&#160;&#160;&#160;8种基本数据作为类的属性时的初始值如下表：\n\n| 基本数据类型 | 初始值 |\n| :------:| :------: |\n| byte | 0 |\n| short | 0 |\n| int | 0 |\n| long | 0 |\n| float | 0.0 |\n| double | 0.0 |\n| char | '\\u0000' |\n| boolean | false |\n\n\n\n## **四、数据类型**\n变量的分类按数据类型进行。对于每一种数据都定义了明确的具体数据类型，在内存中分配了不同大小的内存空间。\njava的数据类型分为 <font color=\"#D2691E\">基本数据类型</font> 和 <font color=\"#D2691E\">引用数据类型</font>。\n\n### **1.基本数据类型有8种**\n**整数类型：**\n&#160;&#160;&#160;&#160;字节型（byte）\n&#160;&#160;&#160;&#160;短整型（short）\n&#160;&#160;&#160;&#160;长整型（long）\n&#160;&#160;&#160;&#160;整型（int）\n\n**小数类型：**\n&#160;&#160;&#160;&#160;单精度（float）\n&#160;&#160;&#160;&#160;双精度（double）\n\n**字符类型（char）：**\n&#160;&#160;&#160;&#160;char只能表示一个字符（英文、中文、标点符号）;\n&#160;&#160;&#160;&#160;可以表示转义字符； 例如：char ch1 = '\\t';\n\n**布尔类型（boolean）：**\n&#160;&#160;&#160;&#160;boolean类型只能够取值为 true 或 false ；不能取值 null。\n\n#### **(1) 字节型（byte）**\n&#160;&#160;&#160;&#160; 占用存储空间：1个字节\n&#160;&#160;&#160;&#160; 表数范围：-128~127\n&#160;&#160;&#160;&#160; 一个字节 = 8位；\n&#160;&#160;&#160;&#160; 最大值：0 1 1 1 1 1 1 1 （这是一个字节，0 为符号位）；\n&#160;&#160;&#160;&#160; 字节型是最小的整数类型，用byte来表示，其大小占1个字节。\n\n#### **(2) 短整型（short）**\n&#160;&#160;&#160;&#160; 占用存储空间：2个字节\n&#160;&#160;&#160;&#160; 表数范围：-2^15~2^15-1\n\n#### **(3) 整型（int）**\n&#160;&#160;&#160;&#160; 占用存储空间：4个字节\n&#160;&#160;&#160;&#160; 表数范围：-2^31~2^31-1\n&#160;&#160;&#160;&#160; 补充：byte 和 short 计算时，产生的结果默认为 int 型\n\n#### **(4) 长整型（long）**\n&#160;&#160;&#160;&#160; 占用存储空间：8个字节\n&#160;&#160;&#160;&#160; 表数范围：-2^63~2^63-1\n\n#### **(5) 双精度（double）**\n&#160;&#160;&#160;&#160; 占用存储空间：8个字节\n&#160;&#160;&#160;&#160; 表数范围：-1.798E308~1.798E308\n&#160;&#160;&#160;&#160; 补充：如果整型数据在计算的时候 结果出现了小数，结果类型默认为 double\n\n#### **(6) 单精度（float）**\n&#160;&#160;&#160;&#160; 占用存储空间：4个字节\n&#160;&#160;&#160;&#160; 表数范围：-3.403E38~3.403E38\n&#160;&#160;&#160;&#160; 补充：3.403E38 是科学计数法，相当于 3.403*10^38\n&#160;&#160;&#160;&#160; <font color=\"#D2691E\">注意：float 在定义的时候一定要在初始值后加 f，否则会提示精度损失的报错</font>\n&#160;&#160;&#160;&#160; <font color=\"#D2691E\">例如：float price = 20.6f；</font>\n\n#### **(7) 字符型（char）**\n&#160;&#160;&#160;&#160; 占用存储空间：2个字节\n\n### **2.引用数据类型**\n**类（class）；** &#160;&#160; **接口（interface）；** &#160;&#160; **数组（[]）**\n\n","tags":["数据类型"],"categories":["Java"]},{"title":"java开发环境的搭建","url":"/Java/java开发环境的搭建.html","content":"\n\n\n## **1. java术语**\n`JRE：`java runtime environment（java运行环境）\n`JVM：`java virtual machine（java虚拟机），java程序就是在jvm中运行的\n`java核心类库：`jre提供的让程序能运行的java类\n`JDK：`java development kit（java开发工具）\n\n<!-- more -->\n\n![](http://img.blog.csdn.net/20170420210950501?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzM4NDc4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n## **2. jdk文件结构**\n1. `bin：`jdk中所包含的开发工具的可执行命令文件（我们常用的是 java.exe 和 javac.exe）\n2. `db：`里面放了jdk自带的小型数据库系统\n3. `include：`jdk提供的本地接口编程\n4. `jre：`java运行环境\n5. `lib：`java开发包\n6. `src.zip：`源码包（jdk是开源的）\n\n\n\n## **3. jdk的安装**\n  （1）下载jdk [下载](http://www.oracle.com/technetwork/java/javase/downloads)\n  （2）安装jdk\n> **补充：**\n> &#160;&#160;&#160;&#160;如果我们要在docs下执行bin目录中的`java.exe`或者`javac.exe`，那么我们需要在docs中进入到bin目录下，方可执行。（比如我们想通过docs打开qq，同样需要进入到qq的bin目录下，才能执行qq.exe，都是一样的道理）当我们在命令行中无法执行java或javac时，那么有可能就是没有进入到bin目录中去。而如果要想在任意的目录下执行他们的话，我们就必须配置环境变量path\n\n## **4. 配置环境变量**\n<table><tr><td bgcolor=\"#7FFFD4\">\n  步骤一：右击我的电脑------》 属性------》 高级系统设置------》 高级------》 环境变量（有两个区域）\n</td></tr></table>\n\n![这里写图片描述](http://img.blog.csdn.net/20170420221311963?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzM4NDc4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n> **补充：**\n> &#160;&#160;&#160;&#160;下图为path里的参数，SystemRoot 代表系统的根，而本系统的根为 C:\\Windows\n\n\n![这里写图片描述](http://img.blog.csdn.net/20170420221906595?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzM4NDc4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n> **举例：**\n\n> &#160;&#160;&#160;&#160;&#160;（说明配置path的作用）比如 ping.exe 为 C:\\Windows\\System32 下的一个可执行文件，当我们要在docs中去执行ping时，必须进入到System32这个目录下，而假如我们想要在任意目录下都可执行ping时，就必须在path里去配置环境变量。\n> \n  &#160;&#160;&#160;&#160;&#160;&#160;在docs中ping时的执行情况：当我们在F盘下ping的时候，首先OS会在F盘下来查找 ping.exe 的文件，如果在F盘下找到了 ping.exe 那就执行；如果没有找到 ping.exe，那就去环境变量所指定的路径下去找（本系统环境变量所指定的路径为 C:\\Windows\\System32），此时如果找到了，就执行，如果没有找到就提示：”不是内部命令“。\n\n<table><tr><td bgcolor=\"#7FFFD4\">\n  步骤二： path变量的配置（这里有两种方法配置它）\n</td></tr></table>\n\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;<font color=\"#FF0000\" size=\"5\">方法一：</font>直接在path里添加 java.exe 或者 javac.exe 文件的绝对路径（如下图所示）\n\n![这里写图片描述](http://img.blog.csdn.net/20170421154104982?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzM4NDc4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n**注意：**虽然方法一的path配置比较简单，但是像这种写死的方式我们一般是不建议使用的，最好使用方法二较为灵活。\n\n\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;<font color=\"#FF0000\" size=\"5\">方法二：</font>我们首先新建一个 `JAVA_HOME` 变量，再把变量值设置为 `D:\\java\\jdk1.7.0_45`；接下来再去path变量里设置变量值 `%JAVA_HOME%\\bin`。（如下图所示）\n\n![这里写图片描述](http://img.blog.csdn.net/20170421155750298?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzM4NDc4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n![这里写图片描述](http://img.blog.csdn.net/20170421155802689?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzM4NDc4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n> **注意：**\n> &#160;&#160;&#160;&#160;在这里可能有人会问，新建的变量名可不可以不叫 JAVA_HOME，而取别的名，其实是可以的，但是我们为了见名知意，让别人一看你这个就知道是干什么的，所以最好还是取名为 JAVA_HOME。对了，这里需要特别注意的是，每次配置了环境变量之后，都要重启一下docs。\n\n\n<table><tr><td bgcolor=\"#7FFFD4\">\n  步骤三： 新建classpath变量，变量值为：.;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar\n</td></tr></table>\n\n\n![这里写图片描述](http://img.blog.csdn.net/20170421161551680?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzM4NDc4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n\n## **5. 补充环境变量的解析**\n\n1. `JAVA_HOME：`\n&#160;&#160;&#160;&#160;JDK的安装路径。为什么要配置JAVA_HOME环境变量？**一是**为了方便引用，比如，JDK安装在 E:\\java\\jdk1.7.0_15 目录里，则设置JAVA_HOME为该目录路径，那么以后要使用这个路劲的时候，只需要输入`%JAVA_HOME%`即可，避免每次每次引用都输入很长的路劲串；**二是**统一原则，当JDK路径改变的时候，只需要更改JAVA_HOME的变量值即可，否则，就要更改任何使用绝对路径引用JDK目录的文档，要是万一没有更改完全，某个程序找不到JDK，后果可想而知。\n\n2. `classpath：`\n&#160;&#160;&#160;&#160;1）java加载类路径。为什么要配置classpath变量？只有配置了classpath变量，才能使得java解析器知道到哪里去找标准类库，这些标准类库是开发JDK的人已经写好的，我们只管使用就行。比如我们常使用到的 java.lang 包中的类，在配置classpath变量后被设置为默认导入，所以在写程序时就不用import这个包了。那么这些标准类库在哪呢？它其实是在JDK的lib目录下以 jar 为后缀的文件中：一个是dt.jar，一个是tools.jar，这两个jar包都位于 E:\\java\\jdk1.7.0_15\\lib 目录下。<font color=\"#D2691E\">配置过程图见上面的步骤三</font>\n<font color=\"red\">在路径前加了个“.”表示当前目录。</font>\n&#160;&#160;&#160;&#160;2）让我们通过命令行可以在任意目录下找到你指定的 class文件 的位置。而无须再进入到 class文件 所在目录下之后再去运行它。（在本机中，我所编写的java代码放在 F:\\zl\\java练习 路径下，所以在classpath的变量值后边加上此路径，<font color=\"#D2691E\">注意变量与变量之间需要加“;”</font>) 配置过程如下图所示：（注意：java运行class时，如果设置了classpath，那么先去classpath下查找要运行的class文件，如果classpath下找不到相应的class文件则会报错，这时我们需要修改classpath的配置。）\n\n3. `path：`\n&#160;&#160;&#160;&#160;为什么要配置path变量？因为系统将根据该变量的值找到java编程中需要的一些程序，比如 java.exe 、 javac.exe等；而且让我们的 java.exe 和 javac.exe 通过命令行可以在任意目录下执行。\n\n\n\n&#160;&#160;&#160;&#160;![这里写图片描述](http://img.blog.csdn.net/20170424152435461?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzM4NDc4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n\n      \n\n      \n\n\n","tags":["java环境变量配置"],"categories":["Java"]},{"title":"初识java","url":"/Java/初识java.html","content":"\n\n## **1. 简单的java程序**\n```java\nclass HelloWorld{\n\tpublic static void main(String[] args){\n\t\tSystem.out.println(\"Hello World\");\t\n\t}\t\n}\n```\n\n> **解释：** class 是类的标识符；HelloWorld 是自定义的类名，<font color=\"red\">该类名一定要和文件名一致，</font>首字符要大写；`public static void main(String[] args){}` 是主方法的入口；大括号要成对出现。\n\n<!-- more -->\n\n## **2. java的运行机制**\n\n我们写的java代码都是源代码（.java），源代码是不能执行的，必须要编译成字节码文件（.class）。\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;编译：javac  文件名.java  （这里的 c 其实就是 compile 编译的意思）\n&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;运行：java  字节码文件名\n*********\n\n**java程序的执行过程：**\n&#160;&#160;&#160;&#160;1)  首先 <font color=\"#D2691E\">java文件</font> 要先编译成 <font color=\"#D2691E\">class文件</font>，然后再把 <font color=\"#D2691E\">class文件</font> 载入到 <font color=\"#D2691E\">JVM</font> 中方可运行。\n&#160;&#160;&#160;&#160;2) 编译好的 class文件 是在我们的硬盘中，但在硬盘中是不能运行 class文件的，必须调到内存里才能运行；当我们在运行class文件时，会立即在内存中创建出一个<font color=\"#D2691E\"> java虚拟机（JVM）</font>，创建完java虚拟机之后，会立马把硬盘中的 class文件 调入到内存当中的 java虚拟机中，此时，JVM就可以运行这个 class文件了。（比如：当我们运行<font color=\"#D2691E\">java HelloWorld </font>时，在内存中创建JVM，然后把 <font color=\"#D2691E\">HelloWorld.class </font>加载到 JVM 中之后再运行，程序执行完成后，JVM立即被释放。）\n&#160;&#160;&#160;&#160;3) JVM其实就是java的字节码文件（.class）运行时在内存当中创建的虚拟机，然后再运行class文件。也就是说，我们在编译的时候根本就没有涉及到运行。\n&#160;&#160;&#160;&#160;4) 那么这个过程显然是 CPU 做的调动。\n\n***********\n\n**java程序简单的运行过程图**\n&#160;&#160;&#160;&#160;![这里写图片描述](http://img.blog.csdn.net/20170424150058085?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzM4NDc4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n \n\n","tags":["初识java"],"categories":["Java"]},{"title":"docs下的常用命令","url":"/Java/docs下的常用命令.html","content":"\n\n### 1. 盘符的切换 \n&#160;&#160;&#160;&#160;&#160;&#160;`d:` 如 切换到d盘 d:\n\n<!-- more -->\n\n  ![切换到d盘](http://img.blog.csdn.net/20170420154916333?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzM4NDc4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n### 2. 展示文件夹下的所有文件和文件夹\n&#160;&#160;&#160;&#160;&#160;&#160;` dir`\n\n![dir](http://img.blog.csdn.net/20170420155517154?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzM4NDc4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n### 3. 创建文件夹\n&#160;&#160;&#160;&#160;&#160;&#160; `md 文件夹名称`，如：md filename\n\n![这里写图片描述](http://img.blog.csdn.net/20170420160324963?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzM4NDc4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n### 4. 创建文件\n&#160;&#160;&#160;&#160;&#160;&#160; `copy con 文件名`，如：copy con 1.txt，使用 `ctrl + c` 来结束\n\n![这里写图片描述](http://img.blog.csdn.net/20170420161311014?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzM4NDc4OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n### 5. 目录的切换\n&#160;&#160;&#160;&#160;&#160;&#160;`cd 目录名`，如：cd filename 切换到filename目录\n&#160;&#160;&#160;&#160;&#160;&#160;`cd.`，切换到当前目录\n&#160;&#160;&#160;&#160;&#160;&#160;`cd..`，切换到上一层目录\n&#160;&#160;&#160;&#160;&#160;&#160;`cd/`，切换到当前盘符的根目录\n\n### 6. 删除文件夹\n&#160;&#160;&#160;&#160;&#160;&#160; `rd 文件夹名`，（文件夹是空的）\n\n### 7. 删除文件\n&#160;&#160;&#160;&#160;&#160;&#160; `del 文件名`，（可以使用通配符）如：del 1.txt\n> 注意：如果删除多个文件，可以使用逗号方式来分隔多个文件\n\n&#160;&#160;&#160;&#160;&#160;&#160; 可以使用通配符方式：`del *.txt `（会删掉所有以.txt为结尾的文件）；`del *` （删除所有文件）\n\n### 8. 清屏\n&#160;&#160;&#160;&#160;&#160;&#160;  `cls`\n\n### 9. 显示当前操作系统下所有的环境变量\n &#160;&#160;&#160;&#160;&#160;&#160;  `set`\n \n **查询某一个具体的环境变量：**\n &#160;&#160;&#160;&#160;set 变量名\n &#160;&#160;&#160;&#160;例如：set path\n\n**设置临时环境变量：**\n &#160;&#160;&#160;&#160;set 变量名 = 变量值\n &#160;&#160;&#160;&#160;例如：set classpath=.;f:/zl/java练习\n &#160;&#160;&#160;&#160;注意：临时环境变量，只在当前的docs窗口有效，如果窗口关闭临时环境变量就是失效\n\n\n                                                                                        ","tags":["docs命令"],"categories":["Java"]}]